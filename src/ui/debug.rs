use std::path::Path;

use sdl2::{image::SaveSurface, pixels::PixelFormatEnum, surface::Surface};
use specs::World;

use super::SDLError;
use crate::assets::AssetManager;
use crate::map::FloorMap;

use super::renderer::{render_area, RenderContext, RenderData};

/// Render the entire state of the level (the entire map) to the given filename.
///
/// Useful for debugging. This function is fairly "slow", so use sparingly.
pub fn render_to_file<P: AsRef<Path>>(
    map: &FloorMap,
    world: &World,
    path: P,
) -> Result<(), SDLError> {
    //TODO: This code is super fragile. It relies on the SpriteIds generated by the main
    // asset manager corresponding to the asset manager declared here. This only works now
    // because we happen to use the same constructor. If the code there or the code here
    // changes, this assumption could be *very* wrong.

    let level_boundary = map.level_boundary();
    let mut canvas = Surface::new(
        level_boundary.width(),
        level_boundary.height(),
        PixelFormatEnum::RGBA8888,
    )
    .and_then(|c| c.into_canvas())
    .map_err(SDLError)?;
    let texture_creator = canvas.texture_creator();

    let tile_size = 16;
    let AssetManager {
        textures,
        map_sprites,
        sprites,
        ..
    } = AssetManager::load(&texture_creator, 30, tile_size)?;

    let mut ctx = RenderContext::new(&mut canvas, &textures, &sprites, &map_sprites);

    let data: RenderData = world.system_data();
    render_area(data, map, level_boundary, &mut ctx, |_, _| true)?;

    canvas.into_surface().save(path).map_err(SDLError)?;
    Ok(())
}
