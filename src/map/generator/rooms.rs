use rand::{StdRng, Rng};

use super::{MapGenerator, RanOutOfAttempts};
use map::*;

impl MapGenerator {
    pub(in super) fn generate_rooms(
        &self,
        rng: &mut StdRng,
        map: &mut FloorMap,
        level: usize,
    ) -> Result<Vec<(RoomId, Room)>, RanOutOfAttempts> {
        let mut rooms = self.generate_special_rooms(rng, map, level)?;

        let mut attempts = 0;
        while rooms.len() < self.rooms {
            if attempts > self.attempts {
                return Err(RanOutOfAttempts);
            }
            attempts += 1;

            let room = self.find_room_spot(&rooms, || self.random_room(rng, RoomType::Normal))?;
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        Ok(rooms)
    }

    fn generate_special_rooms(
        &self,
        rng: &mut StdRng,
        map: &mut FloorMap,
        level: usize,
    ) -> Result<Vec<(RoomId, Room)>, RanOutOfAttempts> {
        let mut rooms = Vec::new();

        // If we're on the first level, generate the room where the player will spawn
        if level == 1 {
            let room = self.find_room_spot(&rooms, || self.random_room(rng, RoomType::PlayerStart))?;
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        // If we're on the last level, generate the treasure chamber
        if level == self.levels {
            let room = self.find_room_spot(&rooms, || {
                let pos = TilePos {
                    row: rng.gen_range(0, self.rows),
                    col: rng.gen_range(0, self.cols),
                };
                let size = GridSize {
                    rows: self.treasure_chamber_height,
                    cols: self.treasure_chamber_width,
                };
                Room::with_type(RoomType::TreasureChamber, pos, size)
            })?;
            let room_id = map.add_room(room);
            rooms.push((room_id, room));
        }

        Ok(rooms)
    }

    fn random_room(&self, rng: &mut StdRng, rtype: RoomType) -> Room {
        let pos = TilePos {
            row: rng.gen_range(0, self.rows),
            col: rng.gen_range(0, self.cols),
        };
        let size = GridSize {
            rows: self.room_rows.gen(rng),
            cols: self.room_cols.gen(rng),
        };
        Room::with_type(rtype, pos, size)
    }

    /// Attempts to place one of the rooms generated by room_gen. Stops and returns the first room
    /// that is able to be placed. Will loop forever if no fitting room is ever generated.
    fn find_room_spot<R>(&self, rooms: &[(RoomId, Room)], mut room_gen: R) -> Result<Room, RanOutOfAttempts>
        where R: FnMut() -> Room {
        'find_rooms: for _ in 0..self.attempts {
            let room = room_gen();

            // Ensure that the room is within the bounds
            let bottom_right = room.bottom_right();
            if bottom_right.row >= self.rows || bottom_right.col >= self.cols {
                continue;
            }

            // Ensure no overlap with any other room
            for (_, other_room) in rooms {
                // Rooms cannot be directly adjacent to each other, this makes enough room for a
                // passage to come through
                let other_room = other_room.expand(self.passage_size);
                if room.has_intersection(other_room) {
                    continue 'find_rooms;
                }
            }
            return Ok(room);
        }

        return Err(RanOutOfAttempts);
    }

    /// Places each room onto the map itself
    pub(in super) fn place_rooms(
        &self,
        map: &mut FloorMap,
        rooms: &[(RoomId, Room)],
        room_sprite: SpriteImage,
        wall_sprite: SpriteImage,
    ) {
        for &(room_id, ref room) in rooms {
            for pos in room.tile_positions() {
                map.grid_mut().place_tile(pos, TileType::Room(room_id), room_sprite);
            }

            for edge in room.edge_positions() {
                map.grid_mut().get_mut(edge)
                    .expect("bug: should have just placed room tile here")
                    .become_wall(wall_sprite);
            }
        }
    }
}
